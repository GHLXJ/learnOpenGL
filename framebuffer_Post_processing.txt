//反相
	//FragColor = vec4(1.0 - texture(material.diffuse_tex,TexCoord).rgb,1.0);
	//灰度
	//FragColor = texture(material.diffuse_tex,TexCoord);
	//float average = (FragColor.r + FragColor.g + FragColor.b)/3.0f;
	//FragColor = vec4(vec3(average),1.0f);
	//灰度使用加权通道：眼会对绿色更加敏感一些，而对蓝色不那么敏感，所以为了获取物理上更精确的效果，我们需要使用加权的(Weighted)通道
	//FragColor = texture(material.diffuse_tex,TexCoord);
	//float average = 0.2126 * FragColor.r + 0.7152 * FragColor.g + 0.0722 * FragColor.b;
	//FragColor = vec4(vec3(average),1.0f);
	//核效果
	//vec2 offsets[9] = vec2[](
    //    vec2(-offset,  offset), // 左上
    //    vec2( 0.0f,    offset), // 正上
    //    vec2( offset,  offset), // 右上
    //    vec2(-offset,  0.0f),   // 左
    //    vec2( 0.0f,    0.0f),   // 中
    //    vec2( offset,  0.0f),   // 右
    //    vec2(-offset, -offset), // 左下
    //    vec2( 0.0f,   -offset), // 正下
    //    vec2( offset, -offset)  // 右下
    //);
	//float kernel[9] = float[](
    //    -1, -1, -1,
    //    -1,  9, -1,
    //    -1, -1, -1
    //);
	//vec3 sampleTex[9];
    //for(int i = 0; i < 9; i++)
    //{
    //    sampleTex[i] = vec3(texture(material.diffuse_tex, TexCoord.st + offsets[i]));
    //}
	//vec3 col = vec3(0.0);
    //for(int i = 0; i < 9; i++)
    //    col += sampleTex[i] * kernel[i];
	//FragColor = vec4(col, 1.0);
	//模糊
	//vec2 offsets[9] = vec2[](
    //    vec2(-offset,  offset), // 左上
    //    vec2( 0.0f,    offset), // 正上
    //    vec2( offset,  offset), // 右上
    //    vec2(-offset,  0.0f),   // 左
    //    vec2( 0.0f,    0.0f),   // 中
    //    vec2( offset,  0.0f),   // 右
    //    vec2(-offset, -offset), // 左下
    //    vec2( 0.0f,   -offset), // 正下
    //    vec2( offset, -offset)  // 右下
    //);
	//float kernel[9] = float[](
    //1.0 / 16, 2.0 / 16, 1.0 / 16,
    //2.0 / 16, 4.0 / 16, 2.0 / 16,
    //1.0 / 16, 2.0 / 16, 1.0 / 16  
	//);
	//vec3 sampleTex[9];
    //for(int i = 0; i < 9; i++)
    //{
    //    sampleTex[i] = vec3(texture(material.diffuse_tex, TexCoord.st + offsets[i]));
    //}
	//vec3 col = vec3(0.0);
    //for(int i = 0; i < 9; i++)
    //    col += sampleTex[i] * kernel[i];
	//FragColor = vec4(col, 1.0);
	//边缘检测
	//vec2 offsets[9] = vec2[](
    //    vec2(-offset,  offset), // 左上
    //    vec2( 0.0f,    offset), // 正上
    //    vec2( offset,  offset), // 右上
    //    vec2(-offset,  0.0f),   // 左
    //    vec2( 0.0f,    0.0f),   // 中
    //    vec2( offset,  0.0f),   // 右
    //    vec2(-offset, -offset), // 左下
    //    vec2( 0.0f,   -offset), // 正下
    //    vec2( offset, -offset)  // 右下
    //);
	//float kernel[9] = float[](
    //1.0, 1.0, 1.0,
    //1.0, -8.0, 1.0,
    //1.0, 1.0, 1.0  
	//);
	//vec3 sampleTex[9];
    //for(int i = 0; i < 9; i++)
    //{
    //    sampleTex[i] = vec3(texture(material.diffuse_tex, TexCoord.st + offsets[i]));
    //}
	//vec3 col = vec3(0.0);
    //for(int i = 0; i < 9; i++)
    //    col += sampleTex[i] * kernel[i];
	//FragColor = vec4(col, 1.0);